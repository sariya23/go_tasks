# Объяснение solution_1

## Вопрос 1 - Что выведет на экран и сколько времени будет работать?

На экран выведется 10000. 

Время работы будет быстрее, чем sleep_time * request_num, так как критическая секция у горутин только на инкремент счетчика, а не на всю функции. То есть горутиы смогут одноверменно спать, что как раз больше всего и замедляет их выполнение - это есть в бенчмарке, - пока критическая секция захвачена. 

## Вопрос 2 - Нужно ускорить, чтобы работало быстрее. Сколько будет работать теперь?

```shell
InitFunc-12             31.85m ±  6%
AtomicFunc-12           27.35m ± 10%
SemaFunc-12             45.26m ± 19%
CriticalSchemaFunc-12    11.07 ±  0%
```

Реализация через атомики оказалась самая быстрая. И памяти меньше всего потребовало аллоцировать.

## Вопрос 3 - Если бы в networkRequest выполнялся реальный сетевой вызов, то какие с какими проблемами мы могли бы столкнуться в данном коде?

Высокая нагрузка на целевой сервер, так как критическая секция стоит только на инкремент.

Такое большое кол-во запросов может отпасть по таймауту, так как мы отправим на сервер 10_000 запросов и они там встанут в очередь, те соединение будет висеть, а следовательно таймаут будет истекать, и будут ждать выполнения. 

Еще сервер может решить, что это DDoS и тогда плаки-плаки.

## Вопрос 4 - Если url немного, а запросов к ним много, то как можно оптимизировать?


# Решение №1 (sariya)

```go
import (
	"fmt"
	"runtime"
)

func main() {
	runtime.GOMAXPROCS(1)
	ch := 0
	go func() {
		ch = 1
	}()
	for ch == 0 {
	}
	fmt.Println("finish")
}
```
Что тут происходит. Изначально мы запускаем программу с одним Processor - у нас есть только одна LRQ и только одна горутина может выполняться в один момент времени. Также есть гонка данных, так как одна из горутин пишет в переменную.

Мы запускаем горутину, в которой присваиваем переменной `ch` значение 1. Так как горутины выполняются не сразу, то она просто добавляется планировщику "на будущее". Далее запускается цикл до тех пор, пока `ch` будет не ноль. Мы прокрутимся в этом цикле до тех пор, пока планировщик, а точнее sysmon, не скажет основной горутине: "Эй, бро, слишком долго, дай другим поработать. Там еще горутина есть, ждет сидит." Если я правильно помню, то sysmon посылает сигнал, если выполнение занимает больше 10мс. Сигнал послался, `main` горутина встала на стоп и начала выполняться другая горутина, в ней присвоилось `ch` 1 и она завершается. Планировщик возвращается к `main` горутине и цикл видит, что `ch` уже равно 1, поэтому выходит из цикла и печатает `finish`. 

Если бы этот код выполнялся в версии Go < 1.14, то он мог зависнуть, так как раньше переключение было только в случае если:
- Есть блокирующая операция
- Происходит вызов другой функции (пролог).
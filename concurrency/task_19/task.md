
===========================================================
Сложная задача.

Реализация распределенного буфера.

Вым необходимо реализовать буфер, который позволяет чтение и запись n-ому количеству горутин.
На сами горутины повлиять невозможно, в решении нельзя использовать wg.
Реализация должна быть защищена от состоятиня гонки или дедлока.
Какой самый оптимальный способ реализации.

===========================================================

```go
type Node struct {
    value []byte
    next *Node
}

type Buffer struct {
    top *Node
}
  
func (b Buffer) Read() []byte {
    // Здесь нужно извлечь последнюю ноду, которая сейчас есть в Buffer. По сути Buffer - это стэк, и метод Read - это Pop
     // ...
}
  
func (b Buffer) Write(data []byte) {
    // Здесь нужно добавить новую ноду к последней в буффере. По сути Buffer - это стэк, и метод Write - это Push
     // ...
}
  
func main() {
    var buffer = Buffer{ ... }
  
    for i := 0; i < 5; i++ {
        go func(i int) {
            buffer.Write([]byte(fmt.Sprintf("data-%d ", i)))
        }(i)
    }
  
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Printf("Read: %s\n", buffer.Read())
        }()
    }
}
```

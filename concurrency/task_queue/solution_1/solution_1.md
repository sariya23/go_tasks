# Решение

Основные ограничения:
- Нельзя использовать `len`;
- Нельзя использовать `cap`;
- Нельзя использовать счетчики и циклы.

Можно конечно намудрить, скорее даже придумать что-то рабочее. Но у нас в языке есть то, что уже реализует очередь FIFO. И может хранить коллекцию элементов. И это конечно же буферезированные каналы. Задача проще, чем кажется.

Каналы в купе с `select` позволяют реализовать блокировку в случае, если места уже нет.

Поясню на примере `Get`:
```go
func (q Queue) Get(block bool) (int, error) {
	select {
	case v := <-q.data:
		return v, nil
	default:
		if block {
			v := <-q.data
			return v, nil
		} else {
			return 0, ErrEmpty
		}
	}
}
```
В случае, если мы может получить значение из канала (то есть буфер канала **не** пуст, то мы попадем в case `v := <-q.data`), то мы просто возвращаем это значение.
Если же нет, то есть 2 варианта развития события - ветка `default` с `if` внутри:
- Если мы хотим ожидать, пока значение появится (`block = true`), то блокируем вызов до момента, пока не появится значение;
- Если мы ленивые и ждать не хотим, то сразу же возвращаем ошибку без блокировки.

`Put` работает аналогичным образом.